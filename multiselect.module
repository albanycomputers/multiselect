<?php
// $Id$

/**
 * @file
 * Allows users to select multiple items in an easier way than the normal node-reference widget.
 */


/**
 * Implements hook_help().
 */
function multiselect_help($path, $arg) {
  $output = '';
  switch ($path) {
    case 'admin/help#multiselect':
      $output = '<p>' . t('Provides a CCK widget for editing fields that allows users to select from a list of options in a left box and have them visually moved into the right box when options are chosen.') . '</p>';
      break;
  }
  return $output;
}

/**
 * Implements hook_form_alter().
 */
function multiselect_form_alter(&$form, &$form_state, $form_id) {
  // Provide additional help for the field settings form.
  switch ($form_id) {
    case 'field_ui_field_edit_form':
      if (isset($form['instance']['widget'])) {
        $widget_type = $form['instance']['widget']['type']['#value'];
        $field_type = $form['#field']['type'];
        $label = $form['instance']['label']['#default_value'];

        if (in_array($widget_type, array('multiselect'))) {
          if (in_array($field_type, array('list', 'list_number', 'list_text', 'taxonomy_term_reference'))) {
            // CCK user_reference and node_reference fields don't need allowed values list.
            // For other field types, if no 'allowed values' were set yet, add a reminder message.
            if (empty($form['field']['settings']['allowed_values']['#default_value'])) {
              drupal_set_message(t("You need to specify the 'allowed values' for this field."), 'warning');
              dsm($form['field']);
            }
          }
        }
      }
      break;
    default:
      //dsm($form);
      break;
  }
}

/**
 * Implement hook_field_widget_info().
 */
function multiselect_field_widget_info() {
  return array(
    'multiselect' => array(
      'label' => t('Multiselect'),
      'field types' => array('list', 'list_text', 'list_number', 'node_reference', 'taxonomy_term_reference', 'user_reference'),
      'behaviors' => array(
        'multiple values' => FIELD_BEHAVIOR_CUSTOM,
        'default value' => FIELD_BEHAVIOR_CUSTOM,
      ),
    ),
  );
}

/**
 * Implements hook_element_info().
 *
 * Any FAPI callbacks needed for individual widgets can be declared here,
 * and the element will be passed to those callbacks for processing.
 */
/*
function multiselect_element_info() {
  return array(
    'multiselect' => array(
      '#process' => array('multiselect_process'),
    ),
  );
}
*/

/**
 * Implements hook_field_widget_form().
 * Build the form widget using Form API (as much as possible).
 */
function multiselect_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  /* START copy from options.module */
  // Abstract over the actual field columns, to allow different field types to
  // reuse those widgets.
  $value_key = key($field['columns']);

  $type = str_replace('options_', '', $instance['widget']['type']);
  //$multiple = $field['cardinality'] > 1 || $field['cardinality'] == FIELD_CARDINALITY_UNLIMITED;
  $multiple = $field['cardinality'];
  $required = $element['#required'];
  $has_value = isset($items[0][$value_key]);
  $properties = _options_properties($type, $multiple, $required, $has_value);

  // Prepare the list of options.
  $options = _options_get_options($field, $instance, $properties);

  // Put current field values in shape.
  $default_value = _options_storage_to_form($items, $options, $value_key, $properties);
  /* END copy from options.module */

  // Insert Javascript and CSS for this widget.
  $path = drupal_get_path('module', 'multiselect');
  drupal_add_js($path . '/multiselect.js');
  drupal_add_css($path . '/multiselect.css');

  // For this specific widget, HTML should be filtered out and entities left unencoded.
  // See content_allowed_values / content_filter_xss / filter_xss.
  _multiselect_allowed_values_filter_html($options);

  // Create some arrays for use later in the function.
  $selected_options = array();
  $unselected_options = array();
  // Add selected items to the array first
  // TODO: still need to get this working with field type 'taxonomy_term_reference'.
  if (is_array($items)) {
    foreach ($items as $key => $value) {
      //$selected_options[$value] = _multiselect_allowed_values_filter_html($value);
      $selected_options[$value['value']] = $value['value'];
    }
  }
  // Add the remaining options to the arrays
  foreach ($options as $key => $value) {
    if (!isset($selected_options[$key])) {
      $unselected_options[$key] = $value;
      //$selected_options[$key] = $value;
    }
  }

  // Set up useful variables.
  $addbutton = $element['#field_name'] . "_add";
  $removebutton = $element['#field_name'] . "_remove";
  $selfield = $element['#field_name'] . "_sel";
  $unselfield = $element['#field_name'] . "_unsel";

  // Call methods to create prefix. (ie the non-selected table, etc)
  $prefix_pre = '<div class="form-item multiselect"><label for="edit-title">' . t($element['#title']) . ':';
  if ($required) {
    $prefix_pre .= '<span class="form-required" title="' . t('This field is required.') . '"> * </span>';
  }
  $prefix_pre .= "</label>\n";
  $prefix_pre .= "<div id=\"multiselect_labels" . "_" . $element['#field_name'] . "\" class=\"multiselect_labels\"><div id=\"label_unselected" . "_" . $element['#field_name'] . "\" class=\"label_unselected\">" . t('Available Options') . ":</div>\n";
  $prefix_pre .= "<div id=\"label_selected" . "_" . $element['#field_name'] . "\" class=\"label_selected\">" . t('Selected Options') . ":</div>\n</div>\n";
  $prefix_pre .= "<div id=\"multiselect_available" . "_" . $element['#field_name'] . "\" class=\"multiselect_available\">";
  $prefix_pre .= _multiselect_html_for_unselected_box_start($unselfield, $element['#field_name']);
  $prefix_options = _multiselect_html_for_unselected_box_options($unselected_options);
  $prefix_post = "</select>\n</div>\n";
  $prefix_post .= _html_for_buttons($element['#field_name']);

  // Build the basic select box using Form API.
  $element += array(
    '#type' => 'select',
    '#title' => $element['#title'],
    '#description' => $element['#description'],
    '#required' => $required,
    '#multiple' => $multiple,
    '#options' => $options,
    //'#options' => $selected_options,
    '#size' => 10,
    '#prefix' => $prefix_pre . $prefix_options . $prefix_post,
    '#suffix' => "\n</div>\n",
    '#attributes' => array('class' => array("$selfield multiselect_sel"), 'id' => array($element['#field_name'])),
    '#default_value' => $default_value,
    //'#post_render' => array('_mm_cleanup'),
    '#value_key' => $value_key,
    '#element_validate' => array('options_field_widget_validate'),
    '#properties' => $properties,
  );

  return $element;
}

function _mm_cleanup($content, $elements) {
  //drupal_set_message('elements:');
  //dsm($elements);
  return $content;
}


/**
 * Implements hook_field_error().
 */
function multiselect_field_widget_error($element, $error) {
  switch ($error['error']) {
    case 'field_cardinality':
      form_error($element, $error['message']);
      break;
  }
}

/**
 * Implements hook_field_widget_form().
 * Build the form widget using Form API (as much as possible).
 */
/*
function multiselect_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $element) {
  switch ($instance['widget']['type']) {
    case 'multiselect':
      $element = array(
        '#type' => 'multiselect',
        '#default_value' => $items,
      );
      break;
  }
  return $element;
}
*/

/**
 * Implements hook_theme().
 */
/*
function multiselect_theme() {
  return array(
    'multiselect' => array(
      'arguments' => array('element' => NULL),
    ),
  );
}
*/

/**
 * FAPI theme for an individual elements.
 *
 * The textfield or select is already rendered by the
 * textfield or select themes and the html output
 * lives in $element['#children']. Override this theme to
 * make custom changes to the output.
 *
 * $element['#field_name'] contains the field name
 * $element['#delta]  is the position of this element in the group
 */
/*
function theme_multiselect($element) {
  return $element['#children'];
}
*/

/**
 * Copied from D6 CCK content module. Not sure where this went in D7.
 * Filter out HTML from allowed values array while leaving entities unencoded.
 *
 * @see content_allowed_values()
 * @see optionwidgets_select_process()
 * @see content_handler_filter_many_to_one::allowed_values()
 */
function _multiselect_allowed_values_filter_html(&$options) {
  foreach ($options as $key => $opt) {
    if (is_array($opt)) {
      _multiselect_allowed_values_filter_html($options[$key]);
    }
    else {
      $options[$key] = html_entity_decode(strip_tags($opt), ENT_QUOTES);
    }
  }
}

/**
 * Provides html to draw the "not selected" box
 */
function _multiselect_html_for_unselected_box_start($unselfield, $fieldname) {
  $boxhtml = '';
  $boxhtml .= "<select name=\"" . $unselfield . "\" multiple=\"multiple\" class=\"form-select " . $unselfield . " multiselect_unsel\" id=\"" . $fieldname . "\" size=\"10\">\n";
  return $boxhtml;
}

function _multiselect_html_for_unselected_box_options($unselected_options) {
  $boxhtml = '';
  foreach ($unselected_options as $value => $name) {
    $boxhtml .= "<option value=\"" . $value . "\">" . $name . "</option>\n";
  }
  return $boxhtml;
}

/**
 * Provides html to display the buttons on the form.
 */
function _html_for_buttons($fieldname) {
  $buttons_code = "<ul id=\"multiselect_btns" . "_" . $fieldname . "\" class=\"multiselect_btns\">
<li class=\"multiselect_add\" id=\"" . $fieldname . "\"><a href=\"javascript:;\">Add</a></li>
<li class=\"multiselect_remove\" id=\"" . $fieldname . "\"><a href=\"javascript:;\">Remove</a></li>
</ul>";
  return $buttons_code;
}